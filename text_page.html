<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - text</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
	</head>
	<body>

		<script type="module">

			import * as THREE from './js/three.js-master/build/three.module.js';
			import Stats from './js/three.js-master/build/stats.module.js';

			THREE.Cache.enabled = true;

			let container, stats;
			let camera, cameraTarget, scene, renderer;
			let group, textMesh, textGeo, materials;
			let firstLetter = true;
			let bevelEnabled = true;
			const height = 10,
				size = 20,
				hover = 3,
				curveSegments = 4,
				bevelThickness = 2,
				bevelSize = 1.5;

			const mirror = true;

			let windowHalfX = window.innerWidth / 2;

			init();
			animate();

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// CAMERA
				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
				camera.position.set( 0, 400, 700 );
				cameraTarget = new THREE.Vector3( 0, 150, 0 );

				// SCENE
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

				// LIGHTS

				const dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
				dirLight.position.set( 0, 0, 1 ).normalize();
				scene.add( dirLight );

				const pointLight = new THREE.PointLight( 0xffffff, 1.5 );
				pointLight.position.set( 0, 100, 90 );
				scene.add( pointLight );

				materials = [
					new THREE.MeshPhongMaterial( { color: 0x03fc84, flatShading: true } ), // front
					new THREE.MeshPhongMaterial( { color: 0x03fc84 } ) // side
				];

				let text = " Tap Space For Start !";
				createText(text);


				// RENDERER
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				// STATS
				stats = new Stats();
				//container.appendChild( stats.dom );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function createText(text) {

				console.log("loadFont");
				const loader = new THREE.FontLoader();
				loader.load( './resource/font.json', function ( response ) {

					let font = response;
					drawText(text, font);

				} );

			}

			function drawText(text, font) {
				textGeo = new THREE.TextGeometry( text, {

					font: font,

					size: size,
					height: height,
					curveSegments: curveSegments,

					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: bevelEnabled

				} );

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();


				const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				textGeo = new THREE.BufferGeometry().fromGeometry( textGeo );

				textMesh = new THREE.Mesh( textGeo, materials );
				textMesh.position.x = centerOffset;
				textMesh.position.y = 100;
				textMesh.position.z = 0;

				scene.add( textMesh );
			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				camera.lookAt( cameraTarget );

				renderer.clear();
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
